{"ast":null,"code":"import LineChart from \"@/components/Charts/LineChart\";\nimport * as chartConfigs from \"@/components/Charts/config\";\nimport config from \"@/config\";\nimport { ethers } from \"ethers\";\nimport { Campaign, NFTBadge, IPFS } from \"@/config\";\nimport NFTGenerator from \"@/components/NFTGenerator.vue\";\nimport { create } from 'kubo-rpc-client';\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nexport default {\n  components: {\n    LineChart,\n    'nft-generator': NFTGenerator\n  },\n  props: {\n    id: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      donationAmount: \"\",\n      ipfsHash: \"\",\n      errorMessage: \"\",\n      uploadMessage: \"\",\n      localProvider: null,\n      ipfsContract: null,\n      campaignContract: null,\n      nftBadgeContract: null,\n      nftHash: null,\n      campaign: {\n        id: 1,\n        name: \"Save the Rainforest\",\n        description: \"Help us save the Amazon rainforest by funding reforestation projects.\",\n        dollarsNeeded: 500000,\n        dollarsFunded: 120000,\n        image: \"https://placehold.co/600x400/EEE/31343C\",\n        viewedLastHour: 90\n      },\n      greenLineChart: {\n        extraOptions: chartConfigs.greenChartOptions,\n        chartData: {\n          labels: [\"Day 1\", \"Day 2\", \"Day 3\", \"Day 4\", \"Day 5\"],\n          datasets: [{\n            label: \"Donations (in USD)\",\n            fill: true,\n            borderColor: config.colors.primary,\n            borderWidth: 2,\n            borderDash: [],\n            borderDashOffset: 0.0,\n            pointBackgroundColor: config.colors.primary,\n            pointBorderColor: \"rgba(255,255,255,0)\",\n            pointHoverBackgroundColor: config.colors.primary,\n            pointBorderWidth: 20,\n            pointHoverRadius: 4,\n            pointHoverBorderWidth: 15,\n            pointRadius: 4,\n            data: [80, 100, 70, 80, 120, 80]\n          }]\n        },\n        gradientColors: [\"rgba(66,134,121,0.15)\", \"rgba(66,134,121,0.0)\", \"rgba(66,134,121,0)\"],\n        gradientStops: [1, 0.4, 0]\n      }\n    };\n  },\n  computed: {\n    progressPercentage() {\n      return (this.campaign.dollarsFunded / this.campaign.dollarsNeeded * 100).toFixed(2);\n    }\n  },\n  beforeUnmount() {\n    this.nftBadgeContract.removeAllListeners(\"BadgeMinted\");\n  },\n  async created() {\n    this.localProvider = new ethers.providers.JsonRpcProvider(\"http://127.0.0.1:8545\"); // Local Hardhat node\n    this.defaultProvider = new ethers.providers.Web3Provider(window.ethereum);\n    this.ipfsContract = new ethers.Contract(IPFS.address, IPFS.abi, this.defaultProvider);\n    this.campaignContract = new ethers.Contract(Campaign.address, Campaign.abi, this.localProvider);\n    this.nftBadgeContract = new ethers.Contract(NFTBadge.address, NFTBadge.abi, this.localProvider);\n    window.ethereum.enable();\n    this.setupBadgeMintedListener();\n  },\n  methods: {\n    async connectMetaMask() {\n      try {\n        if (!window.ethereum) {\n          throw new Error(\"MetaMask not installed. Please install MetaMask and try again.\");\n        }\n\n        // Request MetaMask to connect\n        await window.ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n        console.log(\"MetaMask connected.\");\n      } catch (error) {\n        console.error(\"Error connecting to MetaMask:\", error.message);\n        alert(\"Error connecting to MetaMask: \" + error.message);\n      }\n    },\n    async readFile() {\n      const signer = await this.localProvider.getSigner();\n      const file = await this.ipfsContract.userFiles(signer.getAddress());\n      if (file !== ZERO_ADDRESS) {\n        this.ipfsHash = file;\n      }\n      return true;\n    },\n    async setFileIPFS(hash) {\n      const ipfsWithSigner = this.ipfsContract.connect(this.localProvider.getSigner());\n      const tx = await ipfsWithSigner.setFileIPFS(hash);\n      await tx.wait(); // Ensure the transaction is mined before proceeding\n      this.ipfsHash = hash;\n    },\n    async handleSubmit() {\n      if (this.donationAmount === \"\" || isNaN(this.donationAmount) || this.donationAmount <= 0) {\n        this.errorMessage = \"Please enter a valid donation amount.\";\n        return;\n      }\n      this.errorMessage = \"\";\n      this.successMessage = \"Processing your donation...\";\n      try {\n        const signer = this.localProvider.getSigner();\n        const campaignWithSigner = this.campaignContract.connect(signer);\n\n        // Send contribution\n        const tx = await campaignWithSigner.contribute({\n          value: ethers.utils.parseEther(this.donationAmount.toString())\n        });\n\n        // Wait for transaction to be mined\n        let receipt = await tx.wait();\n        this.successMessage = \"Donation successful! Waiting for badge generation...\";\n      } catch (error) {\n        console.error(\"Error processing donation:\", error);\n        this.errorMessage = \"There was an issue with your donation. Please try again.\";\n      }\n    },\n    async uploadToIPFS() {\n      this.errorMessage = \"\";\n      this.uploadMessage = \"Uploading image to IPFS...\";\n      try {\n        const client = create({\n          url: \"/ip4/127.0.0.1/tcp/5001\"\n        });\n\n        // Get the canvas data from the child component\n        const nftGenerator = this.$refs['nftGenerator'];\n        if (!nftGenerator) {\n          return;\n        }\n        const canvas = nftGenerator.$refs.canvas;\n\n        // Convert canvas to Blob\n        const canvasBlob = await new Promise(resolve => canvas.toBlob(resolve, \"image/png\"));\n        if (!canvasBlob) {\n          throw new Error(\"Failed to generate canvas image blob.\");\n        }\n\n        // Upload to IPFS\n        const fileResult = await client.add(canvasBlob);\n        const filePath = `/${fileResult.cid}`;\n\n        // Check if file exists in IPFS\n        let fileExists = false;\n        for await (const file of client.files.ls(\"/\")) {\n          if (file.name === fileResult.cid.toString()) {\n            fileExists = true;\n            break;\n          }\n        }\n\n        // Remove the old file if it exists\n        if (fileExists) {\n          await client.files.rm(filePath, {\n            recursive: true\n          });\n        }\n\n        // Copy file to IPFS\n        await client.files.cp(`/ipfs/${fileResult.cid}`, filePath);\n\n        // Display success message\n        this.uploadMessage = \"Image uploaded successfully! CID: \" + fileResult.cid;\n      } catch (error) {\n        console.error(\"Error during upload:\", error.message);\n        this.uploadMessage = \"Error uploading image to IPFS.\";\n      }\n    },\n    setupBadgeMintedListener() {\n      this.nftBadgeContract.removeAllListeners(\"BadgeMinted\");\n      this.nftBadgeContract.on(\"BadgeMinted\", async (badgeId, recipient, tierIndex) => {\n        console.log(\"BadgeMinted event detected:\", badgeId, recipient, tierIndex);\n\n        // Check recipient address and update UI\n        const signerAddress = (await this.localProvider.getSigner().getAddress()).toLowerCase();\n        if (recipient.toLowerCase() === signerAddress) {\n          this.successMessage = `Badge minted successfully! Badge ID: ${badgeId}`;\n          this.nftHash = badgeId._hex;\n          if (this.nftHash) {\n            await this.uploadToIPFS();\n          }\n        }\n      });\n    },\n    async generateNFT(tokenURI) {\n      try {\n        const response = await fetch(tokenURI);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch metadata from ${tokenURI}`);\n        }\n        const metadata = await response.json();\n\n        // Render or use metadata to display the NFT image\n        console.log(\"NFT Metadata:\", metadata);\n        this.successMessage = `NFT generated successfully! View your NFT at ${tokenURI}`;\n      } catch (error) {\n        console.error(\"Error generating NFT:\", error);\n        this.errorMessage = `Failed to generate NFT: ${error.message}`;\n      }\n    }\n  }\n};","map":{"version":3,"names":["LineChart","chartConfigs","config","ethers","Campaign","NFTBadge","IPFS","NFTGenerator","create","ZERO_ADDRESS","components","props","id","type","String","required","data","donationAmount","ipfsHash","errorMessage","uploadMessage","localProvider","ipfsContract","campaignContract","nftBadgeContract","nftHash","campaign","name","description","dollarsNeeded","dollarsFunded","image","viewedLastHour","greenLineChart","extraOptions","greenChartOptions","chartData","labels","datasets","label","fill","borderColor","colors","primary","borderWidth","borderDash","borderDashOffset","pointBackgroundColor","pointBorderColor","pointHoverBackgroundColor","pointBorderWidth","pointHoverRadius","pointHoverBorderWidth","pointRadius","gradientColors","gradientStops","computed","progressPercentage","toFixed","beforeUnmount","removeAllListeners","created","providers","JsonRpcProvider","defaultProvider","Web3Provider","window","ethereum","Contract","address","abi","enable","setupBadgeMintedListener","methods","connectMetaMask","Error","request","method","console","log","error","message","alert","readFile","signer","getSigner","file","userFiles","getAddress","setFileIPFS","hash","ipfsWithSigner","connect","tx","wait","handleSubmit","isNaN","successMessage","campaignWithSigner","contribute","value","utils","parseEther","toString","receipt","uploadToIPFS","client","url","nftGenerator","$refs","canvas","canvasBlob","Promise","resolve","toBlob","fileResult","add","filePath","cid","fileExists","files","ls","rm","recursive","cp","on","badgeId","recipient","tierIndex","signerAddress","toLowerCase","_hex","generateNFT","tokenURI","response","fetch","ok","metadata","json"],"sources":["src/pages/CampaignDetail.vue"],"sourcesContent":["<template>\n  <div class=\"campaign-detail\">\n    <div class=\"container\">\n      <!-- Campaign Header -->\n      <div class=\"row mb-4\">\n        <div class=\"col-12 text-center\">\n          <h1 class=\"campaign-title\">{{ campaign.name }}</h1>\n          <p class=\"campaign-description\">{{ campaign.description }}</p>\n        </div>\n      </div>\n\n      <!-- Campaign Image and Info -->\n      <div class=\"row align-items-center\">\n        <div class=\"col-md-6\">\n          <img :src=\"campaign.image\" alt=\"Campaign Image\" class=\"img-fluid rounded shadow\" />\n        </div>\n        <div class=\"col-md-6\">\n          <div class=\"campaign-info\">\n            <p><strong>Funding Progress:</strong></p>\n            <div class=\"progress mb-3\">\n              <div\n                class=\"progress-bar\"\n                role=\"progressbar\"\n                :style=\"{ width: progressPercentage + '%' }\"\n                :aria-valuenow=\"progressPercentage\"\n                aria-valuemin=\"0\"\n                aria-valuemax=\"100\"\n              >\n                {{ progressPercentage }}%\n              </div>\n            </div>\n            <p><strong>Funds Needed:</strong> ${{ campaign.dollarsNeeded }}</p>\n            <p><strong>Funds Raised:</strong> ${{ campaign.dollarsFunded }}</p>\n            <p><strong>Viewed in Last Hour:</strong> {{ campaign.viewedLastHour }}</p>\n            <div class=\"col-md-6\">\n              <div class=\"row mt-5\">\n                <form @submit.prevent=\"handleSubmit\">\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    v-model=\"donationAmount\"\n                    placeholder=\"Donation quantity (USD)\"\n                  />\n                  <p v-if=\"errorMessage\" class=\"error-message\">{{ errorMessage }}</p>\n                  <button type=\"submit\" class=\"btn\">Support campaign</button>\n                </form>\n                <!-- NFT Generator -->\n                <nft-generator v-if=\"nftHash\" ref=\"nftGenerator\" :nftHash=\"nftHash\"></nft-generator>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Campaign Objectives -->\n      <div class=\"row mt-5\">\n        <div class=\"col-12\">\n          <h3>Campaign Objectives</h3>\n          <ul>\n            <li><strong>$100,000:</strong> Saving the forest by protecting endangered areas.</li>\n            <li><strong>$200,000:</strong> Launch a large-scale reforestation project.</li>\n            <li><strong>$500,000:</strong> Create long-term conservation programs involving local communities.</li>\n          </ul>\n        </div>\n      </div>\n\n      <!-- Donation Progress Chart -->\n      <div class=\"row mt-5\">\n        <div class=\"col-12\">\n          <h3>Donation Progress Over Time</h3>\n          <div class=\"chart-area\">\n            <line-chart\n              style=\"height: 100%\"\n              chart-id=\"green-line-chart\"\n              :chart-data=\"greenLineChart.chartData\"\n              :gradient-stops=\"greenLineChart.gradientStops\"\n              :extra-options=\"greenLineChart.extraOptions\"\n            >\n            </line-chart>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n  \n\n<script>\nimport LineChart from \"@/components/Charts/LineChart\";\nimport * as chartConfigs from \"@/components/Charts/config\";\nimport config from \"@/config\";\nimport { ethers } from \"ethers\";\nimport { Campaign, NFTBadge, IPFS } from \"@/config\";\nimport NFTGenerator from \"@/components/NFTGenerator.vue\";\nimport { create } from 'kubo-rpc-client'\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\nexport default {\n  components: {\n    LineChart,\n    'nft-generator': NFTGenerator,\n  },\n  props: {\n    id: {\n      type: String,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      donationAmount: \"\",\n      ipfsHash: \"\",\n      errorMessage: \"\",\n      uploadMessage: \"\",\n      localProvider: null,\n      ipfsContract: null,\n      campaignContract: null,\n      nftBadgeContract: null,\n      nftHash: null,\n      campaign: {\n        id: 1,\n        name: \"Save the Rainforest\",\n        description: \"Help us save the Amazon rainforest by funding reforestation projects.\",\n        dollarsNeeded: 500000,\n        dollarsFunded: 120000,\n        image: \"https://placehold.co/600x400/EEE/31343C\",\n        viewedLastHour: 90,\n      },\n      greenLineChart: {\n        extraOptions: chartConfigs.greenChartOptions,\n        chartData: {\n          labels: [\"Day 1\", \"Day 2\", \"Day 3\", \"Day 4\", \"Day 5\"],\n          datasets: [\n            {\n              label: \"Donations (in USD)\",\n              fill: true,\n              borderColor: config.colors.primary,\n              borderWidth: 2,\n              borderDash: [],\n              borderDashOffset: 0.0,\n              pointBackgroundColor: config.colors.primary,\n              pointBorderColor: \"rgba(255,255,255,0)\",\n              pointHoverBackgroundColor: config.colors.primary,\n              pointBorderWidth: 20,\n              pointHoverRadius: 4,\n              pointHoverBorderWidth: 15,\n              pointRadius: 4,\n              data: [80, 100, 70, 80, 120, 80],\n            },\n          ],\n        },\n        gradientColors: [\n          \"rgba(66,134,121,0.15)\",\n          \"rgba(66,134,121,0.0)\",\n          \"rgba(66,134,121,0)\",\n        ],\n        gradientStops: [1, 0.4, 0],\n      },\n    };\n  },\n  computed: {\n    progressPercentage() {\n      return ((this.campaign.dollarsFunded / this.campaign.dollarsNeeded) * 100).toFixed(2);\n    },\n  },\n  beforeUnmount() {\n    this.nftBadgeContract.removeAllListeners(\"BadgeMinted\");\n  },\n  async created() {\n    this.localProvider = new ethers.providers.JsonRpcProvider(\"http://127.0.0.1:8545\"); // Local Hardhat node\n    this.defaultProvider = new ethers.providers.Web3Provider(window.ethereum);\n\n    this.ipfsContract = new ethers.Contract(\n      IPFS.address,\n      IPFS.abi,\n      this.defaultProvider\n    );\n\n    this.campaignContract = new ethers.Contract(\n      Campaign.address,\n      Campaign.abi,\n      this.localProvider\n    );\n\n    this.nftBadgeContract = new ethers.Contract(\n      NFTBadge.address,\n      NFTBadge.abi,\n      this.localProvider\n    );\n\n    window.ethereum.enable();\n\n    this.setupBadgeMintedListener();\n  },\n  methods: {\n    async connectMetaMask() {\n      try {\n        if (!window.ethereum) {\n          throw new Error(\"MetaMask not installed. Please install MetaMask and try again.\");\n        }\n\n        // Request MetaMask to connect\n        await window.ethereum.request({ method: 'eth_requestAccounts' });\n        console.log(\"MetaMask connected.\");\n      } catch (error) {\n        console.error(\"Error connecting to MetaMask:\", error.message);\n        alert(\"Error connecting to MetaMask: \" + error.message);\n      }\n    },\n    async readFile() {\n      const signer = await this.localProvider.getSigner();\n      const file = await this.ipfsContract.userFiles(signer.getAddress());\n      if (file !== ZERO_ADDRESS) {\n        this.ipfsHash = file;\n      }\n      return true;\n    },\n    async setFileIPFS(hash) {\n      const ipfsWithSigner = this.ipfsContract.connect(\n        this.localProvider.getSigner()\n      );\n      const tx = await ipfsWithSigner.setFileIPFS(hash);\n      await tx.wait(); // Ensure the transaction is mined before proceeding\n      this.ipfsHash = hash;\n    },\n    async handleSubmit() {\n      if (this.donationAmount === \"\" || isNaN(this.donationAmount) || this.donationAmount <= 0) {\n        this.errorMessage = \"Please enter a valid donation amount.\";\n        return;\n      }\n\n      this.errorMessage = \"\";\n      this.successMessage = \"Processing your donation...\";\n\n      try {\n        const signer = this.localProvider.getSigner();\n        const campaignWithSigner = this.campaignContract.connect(signer);\n\n        // Send contribution\n        const tx = await campaignWithSigner.contribute({\n          value: ethers.utils.parseEther(this.donationAmount.toString()),\n        });\n\n        // Wait for transaction to be mined\n        let receipt = await tx.wait();\n        \n\n        this.successMessage = \"Donation successful! Waiting for badge generation...\";\n      } catch (error) {\n        console.error(\"Error processing donation:\", error);\n        this.errorMessage = \"There was an issue with your donation. Please try again.\";\n      }\n    },\n    async uploadToIPFS() {\n      this.errorMessage = \"\";\n      this.uploadMessage = \"Uploading image to IPFS...\";\n\n      try {\n        const client = create({ url: \"/ip4/127.0.0.1/tcp/5001\" });\n\n        // Get the canvas data from the child component\n        const nftGenerator = this.$refs['nftGenerator'];\n        if (!nftGenerator) {\n          return;\n        }\n        const canvas = nftGenerator.$refs.canvas;\n\n        // Convert canvas to Blob\n        const canvasBlob = await new Promise((resolve) =>\n          canvas.toBlob(resolve, \"image/png\")\n        );\n\n        if (!canvasBlob) {\n          throw new Error(\"Failed to generate canvas image blob.\");\n        }\n\n        // Upload to IPFS\n        const fileResult = await client.add(canvasBlob);\n\n        const filePath = `/${fileResult.cid}`;\n\n        // Check if file exists in IPFS\n        let fileExists = false;\n        for await (const file of client.files.ls(\"/\")) {\n          if (file.name === fileResult.cid.toString()) {\n            fileExists = true;\n            break;\n          }\n        }\n\n        // Remove the old file if it exists\n        if (fileExists) {\n          await client.files.rm(filePath, { recursive: true });\n        }\n\n        // Copy file to IPFS\n        await client.files.cp(`/ipfs/${fileResult.cid}`, filePath);\n\n        // Display success message\n        this.uploadMessage = \"Image uploaded successfully! CID: \" + fileResult.cid;\n      } catch (error) {\n        console.error(\"Error during upload:\", error.message);\n        this.uploadMessage = \"Error uploading image to IPFS.\";\n      }\n    },\n    setupBadgeMintedListener() {\n      this.nftBadgeContract.removeAllListeners(\"BadgeMinted\");\n      this.nftBadgeContract.on(\"BadgeMinted\", async (badgeId, recipient, tierIndex) => {\n        console.log(\"BadgeMinted event detected:\", badgeId, recipient, tierIndex);\n\n        // Check recipient address and update UI\n        const signerAddress = (await this.localProvider.getSigner().getAddress()).toLowerCase();\n        if (recipient.toLowerCase() === signerAddress) {\n          this.successMessage = `Badge minted successfully! Badge ID: ${badgeId}`;\n          this.nftHash = badgeId._hex;\n          if (this.nftHash) {\n            await this.uploadToIPFS();\n          }\n        }\n      });\n    },\n    async generateNFT(tokenURI) {\n      try {\n        const response = await fetch(tokenURI);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch metadata from ${tokenURI}`);\n        }\n\n        const metadata = await response.json();\n\n        // Render or use metadata to display the NFT image\n        console.log(\"NFT Metadata:\", metadata);\n        this.successMessage = `NFT generated successfully! View your NFT at ${tokenURI}`;\n      } catch (error) {\n        console.error(\"Error generating NFT:\", error);\n        this.errorMessage = `Failed to generate NFT: ${error.message}`;\n      }\n    },\n  }\n};\n\n</script>\n\n<style scoped>\n.campaign-title {\n  font-size: 2rem;\n  font-weight: bold;\n  margin-bottom: 0.5rem;\n}\n.campaign-description {\n  font-size: 1.25rem;\n  color: #6c757d;\n}\n.img-fluid {\n  max-width: 100%;\n  height: auto;\n}\n.campaign-info {\n  font-size: 1.1rem;\n}\n.progress-bar {\n  background-color: #4caf50;\n}\n.chart-area {\n  height: 400px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}