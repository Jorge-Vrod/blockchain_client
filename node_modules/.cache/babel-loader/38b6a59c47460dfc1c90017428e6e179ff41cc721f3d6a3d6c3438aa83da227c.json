{"ast":null,"code":"export default {\n  name: \"NFTGenerator\",\n  props: {\n    nftHash: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      layers: [{\n        name: \"Background\",\n        images: [\"layer1-bg1.png\", \"layer1-bg2.png\", \"layer1-bg3.png\", \"layer1-bg4.png\", \"layer1-bg5.png\"]\n      }, {\n        name: \"Character\",\n        images: [\"layer2-char1.png\", \"layer2-char2.png\", \"layer2-char3.png\", \"layer2-char4.png\", \"layer2-char5.png\", \"layer2-char6.png\"]\n      }, {\n        name: \"Eyes\",\n        images: [\"layer3-eyes1.png\", \"layer3-eyes2.png\", \"layer3-eyes3.png\"]\n      }, {\n        name: \"Accessories\",\n        images: [\"layer3-acc1.png\", \"layer3-acc2.png\", \"layer3-acc3.png\", \"layer3-acc4.png\", \"layer3-acc5.png\"]\n      }],\n      imagesPath: \"/templates/\" // Adjust the path where your images are stored\n    };\n  },\n  methods: {\n    getHashIndex(hash, max) {\n      let total = 0;\n      for (let i = 0; i < hash.length; i++) {\n        total += hash.charCodeAt(i);\n      }\n      return total % max;\n    },\n    async loadImage(src) {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = src;\n        img.onload = () => resolve(img);\n        img.onerror = e => reject(e);\n      });\n    },\n    async generateNFT() {\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Generate the NFT layers\n      for (const layer of this.layers) {\n        const index = this.getHashIndex(this.nftHash, layer.images.length);\n        const imagePath = this.imagesPath + layer.images[index];\n        try {\n          const image = await this.loadImage(imagePath);\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } catch (error) {\n          console.error(`Failed to load image: ${imagePath}`, error);\n        }\n      }\n    },\n    downloadNFT() {\n      const canvas = this.$refs.canvas;\n      const link = document.createElement(\"a\");\n      link.download = `nft-${this.nftHash}.png`;\n      link.href = canvas.toDataURL(\"image/png\");\n      link.click();\n    }\n  },\n  mounted() {\n    this.generateNFT(); // Generate initial NFT\n  }\n};","map":{"version":3,"names":["name","props","nftHash","type","String","required","data","layers","images","imagesPath","methods","getHashIndex","hash","max","total","i","length","charCodeAt","loadImage","src","Promise","resolve","reject","img","Image","onload","onerror","e","generateNFT","canvas","$refs","ctx","getContext","clearRect","width","height","layer","index","imagePath","image","drawImage","error","console","downloadNFT","link","document","createElement","download","href","toDataURL","click","mounted"],"sources":["src/components/NFTGenerator.vue"],"sourcesContent":["<template>\n    <div class=\"nft-generator\">\n      <canvas ref=\"canvas\" width=\"120\" height=\"120\"></canvas>\n    </div>\n</template>\n  \n  <script>\n  export default {\n    name: \"NFTGenerator\",\n    props: {\n      nftHash: {\n        type: String,\n        required: true,\n      },\n    },\n    data() {\n      return {\n        layers: [\n          { name: \"Background\", images: [\"layer1-bg1.png\", \"layer1-bg2.png\", \"layer1-bg3.png\", \"layer1-bg4.png\", \"layer1-bg5.png\"] },\n          { name: \"Character\", images: [\"layer2-char1.png\", \"layer2-char2.png\", \"layer2-char3.png\", \"layer2-char4.png\", \"layer2-char5.png\", \"layer2-char6.png\"] },\n          { name: \"Eyes\", images: [\"layer3-eyes1.png\", \"layer3-eyes2.png\", \"layer3-eyes3.png\"] },\n          { name: \"Accessories\", images: [\"layer3-acc1.png\", \"layer3-acc2.png\", \"layer3-acc3.png\", \"layer3-acc4.png\", \"layer3-acc5.png\"] },\n        ],\n        imagesPath: \"/templates/\", // Adjust the path where your images are stored\n      };\n    },\n    methods: {\n      getHashIndex(hash, max) {\n        let total = 0;\n        for (let i = 0; i < hash.length; i++) {\n          total += hash.charCodeAt(i);\n        }\n        return total % max;\n      },\n      async loadImage(src) {\n        return new Promise((resolve, reject) => {\n          const img = new Image();\n          img.src = src;\n          img.onload = () => resolve(img);\n          img.onerror = (e) => reject(e);\n        });\n      },\n      async generateNFT() {\n        const canvas = this.$refs.canvas;\n        const ctx = canvas.getContext(\"2d\");\n  \n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n  \n        // Generate the NFT layers\n        for (const layer of this.layers) {\n          const index = this.getHashIndex(this.nftHash, layer.images.length);\n          const imagePath = this.imagesPath + layer.images[index];\n  \n          try {\n            const image = await this.loadImage(imagePath);\n            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n          } catch (error) {\n            console.error(`Failed to load image: ${imagePath}`, error);\n          }\n        }\n      },\n      downloadNFT() {\n        const canvas = this.$refs.canvas;\n        const link = document.createElement(\"a\");\n        link.download = `nft-${this.nftHash}.png`;\n        link.href = canvas.toDataURL(\"image/png\");\n        link.click();\n      },\n    },\n    mounted() {\n      this.generateNFT(); // Generate initial NFT\n    },\n  };\n  </script>\n  \n  <style scoped>\n  .nft-generator {\n    text-align: center;\n  }\n  \n  .controls {\n    margin-top: 20px;\n  }\n  \n  canvas {\n    border: 1px solid #ddd;\n    margin-bottom: 20px;\n  }\n  </style>\n  "],"mappings":"AAOA;EACAA,IAAA;EACAC,KAAA;IACAC,OAAA;MACAC,IAAA,EAAAC,MAAA;MACAC,QAAA;IACA;EACA;EACAC,KAAA;IACA;MACAC,MAAA,GACA;QAAAP,IAAA;QAAAQ,MAAA;MAAA,GACA;QAAAR,IAAA;QAAAQ,MAAA;MAAA,GACA;QAAAR,IAAA;QAAAQ,MAAA;MAAA,GACA;QAAAR,IAAA;QAAAQ,MAAA;MAAA,EACA;MACAC,UAAA;IACA;EACA;EACAC,OAAA;IACAC,aAAAC,IAAA,EAAAC,GAAA;MACA,IAAAC,KAAA;MACA,SAAAC,CAAA,MAAAA,CAAA,GAAAH,IAAA,CAAAI,MAAA,EAAAD,CAAA;QACAD,KAAA,IAAAF,IAAA,CAAAK,UAAA,CAAAF,CAAA;MACA;MACA,OAAAD,KAAA,GAAAD,GAAA;IACA;IACA,MAAAK,UAAAC,GAAA;MACA,WAAAC,OAAA,EAAAC,OAAA,EAAAC,MAAA;QACA,MAAAC,GAAA,OAAAC,KAAA;QACAD,GAAA,CAAAJ,GAAA,GAAAA,GAAA;QACAI,GAAA,CAAAE,MAAA,SAAAJ,OAAA,CAAAE,GAAA;QACAA,GAAA,CAAAG,OAAA,GAAAC,CAAA,IAAAL,MAAA,CAAAK,CAAA;MACA;IACA;IACA,MAAAC,YAAA;MACA,MAAAC,MAAA,QAAAC,KAAA,CAAAD,MAAA;MACA,MAAAE,GAAA,GAAAF,MAAA,CAAAG,UAAA;;MAEA;MACAD,GAAA,CAAAE,SAAA,OAAAJ,MAAA,CAAAK,KAAA,EAAAL,MAAA,CAAAM,MAAA;;MAEA;MACA,WAAAC,KAAA,SAAA7B,MAAA;QACA,MAAA8B,KAAA,QAAA1B,YAAA,MAAAT,OAAA,EAAAkC,KAAA,CAAA5B,MAAA,CAAAQ,MAAA;QACA,MAAAsB,SAAA,QAAA7B,UAAA,GAAA2B,KAAA,CAAA5B,MAAA,CAAA6B,KAAA;QAEA;UACA,MAAAE,KAAA,cAAArB,SAAA,CAAAoB,SAAA;UACAP,GAAA,CAAAS,SAAA,CAAAD,KAAA,QAAAV,MAAA,CAAAK,KAAA,EAAAL,MAAA,CAAAM,MAAA;QACA,SAAAM,KAAA;UACAC,OAAA,CAAAD,KAAA,0BAAAH,SAAA,IAAAG,KAAA;QACA;MACA;IACA;IACAE,YAAA;MACA,MAAAd,MAAA,QAAAC,KAAA,CAAAD,MAAA;MACA,MAAAe,IAAA,GAAAC,QAAA,CAAAC,aAAA;MACAF,IAAA,CAAAG,QAAA,eAAA7C,OAAA;MACA0C,IAAA,CAAAI,IAAA,GAAAnB,MAAA,CAAAoB,SAAA;MACAL,IAAA,CAAAM,KAAA;IACA;EACA;EACAC,QAAA;IACA,KAAAvB,WAAA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}